# Java-Lab5

# Отчет по работе: Реализация задач на Java
Бочкарёв Егор ИТ-13,14

## Общее описание
Данный проект представляет собой консольное приложение на Java, которое реализует 7 различных задач:
1. Задание 1. Шаблоны
2. Задание 2. Структурные шаблоны
3. Задание 3. Список
4. Задание 4. Мап
5. Задание 5. Сет
6. Задание 6. Очередь
7. Задание 7. Стрим
8. Задание 8. Стрим

Программа предлагает пользователю выбрать задачу через меню, затем выполняет соответствующую функцию.

## Структура проекта
- Класс `Main` с вызовом всех задач и пользовательским интерфейсом
- Класс `Check` для проверки входных данных

## Детальный анализ методов

### Задание 1 (Шаблоны)

**<ins>Задача:</ins>**

В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка числителя и установка знаменателя.
Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного значения.
Если раннее в вашем варианте не было Дроби, то создайте сущность Дробь со следующими особенностями:
+ Имеет числитель: целое число
+ Имеет знаменатель: целое число
+ Дробь может быть создана с указанием числителя и знаменателя
+ Может вернуть строковое представление вида “числитель/знаменатель”
+ Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может быть отрицательным.
+ Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя.

**<ins>Метод решения:</ins>**
Эта задача решается дополнением класса `Fraction` с прошлой лабораторной работы.

Создаём интерфейс `FractionInterface`. Он нужен для определения методов `getDoubleValue()`, `setNumerator(int numerator)`, `setDenominator(int denominator)`. Таким образом, интерфейс обеспечивает стандарт для работы с дробями: каждый класс, реализующий этот интерфейс, будет иметь эти методы и гарантировать, что они реализованы определённым образом.

Внутри класса 4 поля: `numerator`, `denominator`, `cachedValue` и `isCacheValid`. Также есть конструктор, который: проверяет на 0 знаменатель, задаёт числитель и знаменатель, проверяет на отрицательное значение знаменатель, инваледирует кэш при создании и сокращает дробь.

Кроме этого есть основные геттеры и сеттеры. Геттеры для этой задачи стандартные, а вот сеттеры модернизированные. Сеттер для числителя задаёт числитель, инвалидирует кэш и позваляет сократить число. Сеттер для знаменателя проверяет значение на 0, задаёт знаменатель, делает его положительным, инвалидирует кэш и позваляет сократить число.

Метод `positiveDenominator()` при отрицательном знаменателе меняе его знак на положительный, а знак числителя на отрицательный.

Метод `invalidateCache()` используется для того, чтобы инвалидировать (сделать недействительным) кэшированное вещественное значение дроби. Важно, что дробь кэширует результат деления числителя на знаменатель для ускорения вычислений. Но если дробь изменяется, нужно сбросить кэш, чтобы в следующий раз при запросе обновленное значение снова вычислялось корректно.

Методы `simplify()` и `gcd(int a, int b)` позваляют сокращать дробь с помощью НОД.

Метод это `toString()` отвечает за вывод результата строкой.

Далее следует выполнение всех математических операции с дробями (Сложение, вычитание, умножение и деление) и выполнение с натуральным числом, а не с дробью. В методе с делением проверяется, чтоб не было деления на 0.

Последним идёт меттод `equals(Object obj)`. Метод `equals(Object obj)` используется для проверки, равны ли две дроби. Важно, что метод сравнивает дроби по математическому значению, а не по внутреннему состоянию числителя и знаменателя.

В `Main` создаётся с клавиатуры две дроби. После чего проводятся операции: с дробями, с целым числом и дробью, кэширование вещественного значения дробей, проверка равенства дробей, изменение дроби.

**<ins>Код реализации:</ins>**
```
interface FractionInterface {
    double getDoubleValue();
    void setNumerator(int numerator);
    void setDenominator(int denominator);
}
```

```
public class Fraction implements FractionInterface {
    private int numerator;  // числитель
    private int denominator; // знаменатель
    private Double cachedDoubleValue; // кэшированное вещественное значение
    private boolean isCacheValid; // флаг валидности кэша

    // Конструктор с числителем и знаменателем
    public Fraction(int numerator, int denominator) {
        if (denominator == 0) {
            throw new IllegalArgumentException("Знаменатель не может быть 0");
        }
        this.denominator = denominator;
        this.numerator = numerator;
        positiveDenominator(); // нормализуем знаки
        invalidateCache(); // инвалидируем кэш при создании
        simplify();
    }

    // Геттеры
    public int getNumerator() {
        return numerator;
    }

    public int getDenominator() {
        return denominator;
    }

    public double getDoubleValue() {
        if (!isCacheValid) {
            cachedDoubleValue = (double) numerator / denominator;
            isCacheValid = true;
        }
        return cachedDoubleValue;
    }

    // Сеттеры
    @Override
    public void setNumerator(int numerator) {
        this.numerator = numerator;
        invalidateCache();
        simplify();
    }

    @Override
    public void setDenominator(int denominator) {
        if (denominator == 0) {
            throw new IllegalArgumentException("Знаменатель не может быть равен нулю!");
        }
        this.denominator = denominator;
        positiveDenominator();
        invalidateCache();
        simplify();
    }

    // Делаем знаменатель всегда положительным
    private void positiveDenominator() {
        if (denominator < 0) {
            numerator = -numerator;
            denominator = -denominator;
        }
    }

    // Инвалидация кэша
    private void invalidateCache() {
        isCacheValid = false;
        cachedDoubleValue = null;
    }

    // Упрощение дроби
    public void simplify() {
        int gcd = gcd(Math.abs(numerator), Math.abs(denominator));
        if (gcd > 1) {
            numerator /= gcd;
            denominator /= gcd;
        }
        invalidateCache();
    }

    // Вычисление НОД (наибольшего общего делителя)
    private int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }

    // Переопределение toString
    @Override
    public String toString() {
        return numerator + "/" + denominator;
    }

    // Метод сложения двух дробей
    public Fraction add(Fraction other) {
        int newNumerator = this.numerator * other.denominator + this.denominator * other.numerator;
        int newDenominator = this.denominator * other.denominator;
        return new Fraction(newNumerator, newDenominator);
    }

    // Метод вычитания двух дробей
    public Fraction subtract(Fraction other) {
        int newNumerator = this.numerator * other.denominator - this.denominator * other.numerator;
        int newDenominator = this.denominator * other.denominator;
        return new Fraction(newNumerator, newDenominator);
    }

    // Метод умножения дробей
    public Fraction multiply(Fraction other) {
        int newNumerator = this.numerator * other.numerator;
        int newDenominator = this.denominator * other.denominator;
        return new Fraction(newNumerator, newDenominator);
    }

    // Метод деления дробей
    public Fraction divide(Fraction other) {
        if (other.numerator == 0) {
            throw new IllegalArgumentException("Деление на ноль невозможно.");
        }
        int newNumerator = this.numerator * other.denominator;
        int newDenominator = this.denominator * other.numerator;
        return new Fraction(newNumerator, newDenominator);
    }

    // Метод сложения дроби и целого числа
    public Fraction add(int number) {
        int newNumerator = this.numerator + number * this.denominator;
        return new Fraction(newNumerator, this.denominator);
    }

    // Метод вычитания дроби и целого числа
    public Fraction subtract(int number) {
        int newNumerator = this.numerator - number * this.denominator;
        return new Fraction(newNumerator, this.denominator);
    }

    // Метод умножения дроби и целого числа
    public Fraction multiply(int number) {
        int newNumerator = this.numerator * number;
        return new Fraction(newNumerator, this.denominator);
    }

    // Метод деления дроби на целое число
    public Fraction divide(int number) {
        if (number == 0) {
            throw new IllegalArgumentException("Деление на ноль невозможно.");
        }
        return new Fraction(this.numerator, this.denominator * number);
    }

    // Переопределение equals
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Fraction other = (Fraction) obj;
        return numerator * other.denominator == denominator * other.numerator;
    }
}
```

**<ins>Вывод на экран:</ins>**
Введите числитель: 8

Введите знаменатель: 24

Создана дробь: 1/3

Введите числитель второй дроби: 9

Введите знаменатель второй дроби: 11

Создана дробь: 9/11

Сложение дробей: 38/33

Вычитание дробей: -16/33

Умножение дробей: 3/11

Деление дробей: 11/27

Введите целое число для операции с первой дробью: 2

Сложение с числом: 7/3

Вычитание с числом: -5/3

Умножение на число: 2/3

Деление на число: 1/6

Вещественное значение первой дроби: 0.3333333333333333

Равенство первой и второй дроби: false

Введите новый числитель для первой дроби:

5

Введите новый знаменатель для первой дроби: 

25

Обновленная первая дробь: 1/5
***

### Задание 2 (Структурные шаблоны)

**<ins>Задача:</ins>**

Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из задачи 2.5.4. Необходимо таким образом передать кота в указанный метод, что бы после окончания его работы узнать сколько раз мяукал кот за время его работы. На рисунке показан пример работы. Перед вызовом метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы выводим количество мяуканий на экран. Кота изменять нельзя.

Если раннее в вашем варианте не было Кота, то создайте
+ сущность Кот, которая описывается следующим образом:
    + Имеет Имя (строка)
    + Для создания необходимо указать имя кота.
    + Может быть приведен к текстовой форме вида: “кот: Имя”
    + Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”, вызвать мяуканье можно без параметров.
+ интерфейс Мяуканье: разработайте метод, который принимает набор объектов способных мяукать и вызывает мяуканье у каждого объекта. Мяукающие объекты должны иметь метод со следующей сигнатурой: public void meow();

**<ins>Метод решения:</ins>**


**<ins>Код реализации:</ins>**
```

```

**<ins>Вывод на экран:</ins>**

***

### Задание 3.5 (Список)

**<ins>Задача:</ins>**

Составить программу, которая удаляет из списка L все элементы с указанным значением.

**<ins>Метод решения:</ins>**

**<ins>Код реализации:</ins>**
```

```

**<ins>Вывод на экран:</ins>**

***

### Задание 4.2 (Мап)

**<ins>Задача:</ins>**

На городской олимпиаде по информатике участникам было предложено выполнить 3 задания, каждое из которых оценивалось по 25-балльной шкале. Известно, что общее количество участников первого тура олимпиады не превосходит 250 человек. На вход программы подаются сведения о результатах олимпиады. В первой строке вводится количество участников N. Далее следуют N строк, имеющих следующий формат:

<Фамилия><Имя><Баллы>

Здесь<Фамилия>– строка, состоящая не более чем из 20 символов;<Имя>– строка, состоящая не более чем из 15 символов;<Баллы>– строка, содержащая три целых числа, разделенных пробелом, соответствующих баллам, полученным участником за каждое задание первого тура. При этом <Фамилия> и <Имя>, <Имя> и <Баллы> разделены одним пробелом. Примеры входных строк:

Петрова Ольга 25 18 16

Калиниченко Иван 14 19 15

Напишите программу, которая будет выводить на экран фамилию и имя участника, набравшего максимальное количество баллов. Если среди остальных участников есть ученики, набравшие такое же количество баллов, то их фамилии и имена также следует вывести. При этом имена и фамилии можно выводить в произвольном порядке.

**<ins>Метод решения:</ins>**

**<ins>Код реализации:</ins>**
```

```

**<ins>Вывод на экран:</ins>**

***

### Задание 5.3 (Сет)

**<ins>Задача:</ins>**

Файл содержит текст на русском языке. Напечатать в алфавитном порядке все согласные буквы, которые входят ровно в одно слово.

**<ins>Метод решения:</ins>**


**<ins>Код реализации:</ins>**
```

```

**<ins>Вывод на экран:</ins>**

***

### Задание 6.4 (Очередь)

**<ins>Задача:</ins>**

Проверить равенство участка очереди с i-го по j-й элемент (i < j).

**<ins>Метод решения:</ins>**

**<ins>Код реализации:</ins>**
```

```

**<ins>Вывод на экран:</ins>**

***

### Задание 7.1 (Стрим)

**<ins>Задача:</ins>**

Необходимо написать стрим:
Дан набор объектов типа Point, необходимо взять все Point в разных координатах, убрать с одинаковыми X,Y, отсортировать по X, отрицательные Y сделать положительными и собрать это все в ломаную (объект типа Polyline)
Если раннее в вашем варианте не было задание с классом Point и Polyline, то написать их:
+ класс Point:
    + Координата Х: число.
    + Координата Y: число.
    + Может возвращать текстовое представление вида “{X;Y}”.
+ класс Line (Линия), расположенная на двумерной плоскости, которая описывается:
    + Координата начала: Точка
    + Координата конца: Точка
    + Может возвращать текстовое представление вида “Линия от {X1;Y1} до {X2;Y2}”
+ класс Polyline (Ломаная), которая будет представлять собой ломаную линию. Ломаная линия представляет собой набор следующих характеристик:
    + Имеет массив Точек, через которые линия проходит.
    + Может быть приведена к строковой форме вида “Линия [Т1,T2,…,TN]”, где TN – это результат приведения к строке Точки с номером N

**<ins>Метод решения:</ins>**


**<ins>Код реализации:</ins>**
```

```

**<ins>Вывод на экран:</ins>**

***

### Задание 7.2 (Стрим)

**<ins>Задача:</ins>**

Дан текстовый файл со строками, содержащими имя человека и его номер в следующей форме:

Вася:5

Петя:3

Аня:5

Номера людей могут повторяться. У каких-то людей может не быть номера.
Необходимо написать стрим выполняющую следующее:
читаются все люди из файла, все имена приводится к нижнему регистру, но с первой буквой в верхнем регистре, убираем из перечня всех людей без номеров, а имена оставшихся группируются по их номеру:
[5:[Вася, Аня], 3:[Петя]]

**<ins>Метод решения:</ins>**


**<ins>Код реализации:</ins>**
```

```

**<ins>Вывод на экран:</ins>**

***

## Вспомогательные методы

+ `public int readInt(Scanner scanner)`

Что делает:

Читает из Scanner целое число, пока пользователь не введёт корректное значение.

Как работает (пошагово):
- Заходит в бесконечный цикл while (true).
- Печатает приглашение "Введите целое число: ".
- Проверяет scanner.hasNextInt() — есть ли следующий токен, который можно распарсить как int.
- Если true: читает int num = scanner.nextInt(); и возвращает num.
- Иначе: печатает сообщение об ошибке и вызывает scanner.next() — чтобы "съесть" неверный токен (иначе hasNextInt() будет снова false и цикл застрянет).

Примеры:

При вводе 42 вернёт 42; при вводе abc — попросит ввести ещё раз.

Код:
```
public int readInt(Scanner scanner) {
        while (true) {
            System.out.print("Введите целое число: ");
            if (scanner.hasNextInt()) {
                int num = scanner.nextInt();
                return num;
            } else {
                System.out.println("Ошибка: введите целое число!");
                scanner.next(); // очищаем неверный ввод
            }
        }
    }
```
